// Copyright 2025 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-kms-wrapping. DO NOT EDIT.

package pb

import (
	"context"
	"encoding/base64"

	wrapping "github.com/hashicorp/go-kms-wrapping/v2"
	"google.golang.org/protobuf/proto"
)

var (
	_ = wrapping.Wrapper(nil)
	_ = context.Background()
	_ = proto.Message(nil)
	_ = base64.RawStdEncoding
)

func (x *TestData) Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	type Wrapper interface {
		Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error
	}
	{
		if len(x.WrappedBytes) != 0 {
			info, err := w.Encrypt(ctx, x.WrappedBytes, opts...)
			if err != nil {
				return err
			}
			x.WrappedBytes, err = proto.Marshal(info)
			if err != nil {
				return err
			}
		}
	}
	for i := range x.RepeatedWrappedBytes {
		{
			if len(x.RepeatedWrappedBytes[i]) != 0 {
				info, err := w.Encrypt(ctx, x.RepeatedWrappedBytes[i], opts...)
				if err != nil {
					return err
				}
				x.RepeatedWrappedBytes[i], err = proto.Marshal(info)
				if err != nil {
					return err
				}
			}
		}
	}
	{
		if len(x.WrappedString) != 0 {
			info, err := w.Encrypt(ctx, []byte(x.WrappedString), opts...)
			if err != nil {
				return err
			}
			b, err := proto.Marshal(info)
			if err != nil {
				return err
			}
			x.WrappedString = base64.RawStdEncoding.EncodeToString(b)
		}
	}
	for i := range x.RepeatedWrappedString {
		{
			if len(x.RepeatedWrappedString[i]) != 0 {
				info, err := w.Encrypt(ctx, []byte(x.RepeatedWrappedString[i]), opts...)
				if err != nil {
					return err
				}
				b, err := proto.Marshal(info)
				if err != nil {
					return err
				}
				x.RepeatedWrappedString[i] = base64.RawStdEncoding.EncodeToString(b)
			}
		}
	}
	if s, ok := any(x.WrappedMessage).(Wrapper); ok {
		if err := s.Wrap(ctx, w, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedMessage {
		if s, ok := any(x.RepeatedWrappedMessage[i]).(Wrapper); ok {
			if err := s.Wrap(ctx, w, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedBytesValue != nil {
		{
			if len(x.WrappedBytesValue.Value) != 0 {
				info, err := w.Encrypt(ctx, x.WrappedBytesValue.Value, opts...)
				if err != nil {
					return err
				}
				x.WrappedBytesValue.Value, err = proto.Marshal(info)
				if err != nil {
					return err
				}
			}
		}
	}
	for i := range x.RepeatedWrappedBytesValue {
		if x.RepeatedWrappedBytesValue[i] != nil {
			{
				if len(x.RepeatedWrappedBytesValue[i].Value) != 0 {
					info, err := w.Encrypt(ctx, x.RepeatedWrappedBytesValue[i].Value, opts...)
					if err != nil {
						return err
					}
					x.RepeatedWrappedBytesValue[i].Value, err = proto.Marshal(info)
					if err != nil {
						return err
					}
				}
			}
		}
	}
	if x.WrappedStringValue != nil {
		{
			if len(x.WrappedStringValue.Value) != 0 {
				info, err := w.Encrypt(ctx, []byte(x.WrappedStringValue.Value), opts...)
				if err != nil {
					return err
				}
				b, err := proto.Marshal(info)
				if err != nil {
					return err
				}
				x.WrappedStringValue.Value = base64.RawStdEncoding.EncodeToString(b)
			}
		}
	}
	for i := range x.RepeatedWrappedStringValue {
		if x.RepeatedWrappedStringValue[i] != nil {
			{
				if len(x.RepeatedWrappedStringValue[i].Value) != 0 {
					info, err := w.Encrypt(ctx, []byte(x.RepeatedWrappedStringValue[i].Value), opts...)
					if err != nil {
						return err
					}
					b, err := proto.Marshal(info)
					if err != nil {
						return err
					}
					x.RepeatedWrappedStringValue[i].Value = base64.RawStdEncoding.EncodeToString(b)
				}
			}
		}
	}
	if x.WrappedOptionalString != nil {
		{
			if len(*x.WrappedOptionalString) != 0 {
				info, err := w.Encrypt(ctx, []byte(*x.WrappedOptionalString), opts...)
				if err != nil {
					return err
				}
				b, err := proto.Marshal(info)
				if err != nil {
					return err
				}
				*x.WrappedOptionalString = base64.RawStdEncoding.EncodeToString(b)
			}
		}
	}
	{
		if len(x.WrappedOptionalBytes) != 0 {
			info, err := w.Encrypt(ctx, x.WrappedOptionalBytes, opts...)
			if err != nil {
				return err
			}
			x.WrappedOptionalBytes, err = proto.Marshal(info)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
func (x *TestData) Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	type Unwrapper interface {
		Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error
	}
	{
		if len(x.WrappedBytes) != 0 {
			var info wrapping.BlobInfo
			if err := proto.Unmarshal(x.WrappedBytes, &info); err != nil {
				return err
			}
			b, err := w.Decrypt(ctx, &info, opts...)
			if err != nil {
				return err
			}
			x.WrappedBytes = b
		}
	}
	for i := range x.RepeatedWrappedBytes {
		{
			if len(x.RepeatedWrappedBytes[i]) != 0 {
				var info wrapping.BlobInfo
				if err := proto.Unmarshal(x.RepeatedWrappedBytes[i], &info); err != nil {
					return err
				}
				b, err := w.Decrypt(ctx, &info, opts...)
				if err != nil {
					return err
				}
				x.RepeatedWrappedBytes[i] = b
			}
		}
	}
	{
		if len(x.WrappedString) != 0 {
			b, err := base64.RawStdEncoding.DecodeString(x.WrappedString)
			if err != nil {
				return err
			}
			var info wrapping.BlobInfo
			if err := proto.Unmarshal(b, &info); err != nil {
				return err
			}
			b, err = w.Decrypt(ctx, &info, opts...)
			if err != nil {
				return err
			}
			x.WrappedString = string(b)
		}
	}
	for i := range x.RepeatedWrappedString {
		{
			if len(x.RepeatedWrappedString[i]) != 0 {
				b, err := base64.RawStdEncoding.DecodeString(x.RepeatedWrappedString[i])
				if err != nil {
					return err
				}
				var info wrapping.BlobInfo
				if err := proto.Unmarshal(b, &info); err != nil {
					return err
				}
				b, err = w.Decrypt(ctx, &info, opts...)
				if err != nil {
					return err
				}
				x.RepeatedWrappedString[i] = string(b)
			}
		}
	}
	if s, ok := any(x.WrappedMessage).(Unwrapper); ok {
		if err := s.Unwrap(ctx, w, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedMessage {
		if s, ok := any(x.RepeatedWrappedMessage[i]).(Unwrapper); ok {
			if err := s.Unwrap(ctx, w, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedBytesValue != nil {
		{
			if len(x.WrappedBytesValue.Value) != 0 {
				var info wrapping.BlobInfo
				if err := proto.Unmarshal(x.WrappedBytesValue.Value, &info); err != nil {
					return err
				}
				b, err := w.Decrypt(ctx, &info, opts...)
				if err != nil {
					return err
				}
				x.WrappedBytesValue.Value = b
			}
		}
	}
	for i := range x.RepeatedWrappedBytesValue {
		if x.RepeatedWrappedBytesValue[i] != nil {
			{
				if len(x.RepeatedWrappedBytesValue[i].Value) != 0 {
					var info wrapping.BlobInfo
					if err := proto.Unmarshal(x.RepeatedWrappedBytesValue[i].Value, &info); err != nil {
						return err
					}
					b, err := w.Decrypt(ctx, &info, opts...)
					if err != nil {
						return err
					}
					x.RepeatedWrappedBytesValue[i].Value = b
				}
			}
		}
	}
	if x.WrappedStringValue != nil {
		{
			if len(x.WrappedStringValue.Value) != 0 {
				b, err := base64.RawStdEncoding.DecodeString(x.WrappedStringValue.Value)
				if err != nil {
					return err
				}
				var info wrapping.BlobInfo
				if err := proto.Unmarshal(b, &info); err != nil {
					return err
				}
				b, err = w.Decrypt(ctx, &info, opts...)
				if err != nil {
					return err
				}
				x.WrappedStringValue.Value = string(b)
			}
		}
	}
	for i := range x.RepeatedWrappedStringValue {
		if x.RepeatedWrappedStringValue[i] != nil {
			{
				if len(x.RepeatedWrappedStringValue[i].Value) != 0 {
					b, err := base64.RawStdEncoding.DecodeString(x.RepeatedWrappedStringValue[i].Value)
					if err != nil {
						return err
					}
					var info wrapping.BlobInfo
					if err := proto.Unmarshal(b, &info); err != nil {
						return err
					}
					b, err = w.Decrypt(ctx, &info, opts...)
					if err != nil {
						return err
					}
					x.RepeatedWrappedStringValue[i].Value = string(b)
				}
			}
		}
	}
	if x.WrappedOptionalString != nil {
		{
			if len(*x.WrappedOptionalString) != 0 {
				b, err := base64.RawStdEncoding.DecodeString(*x.WrappedOptionalString)
				if err != nil {
					return err
				}
				var info wrapping.BlobInfo
				if err := proto.Unmarshal(b, &info); err != nil {
					return err
				}
				b, err = w.Decrypt(ctx, &info, opts...)
				if err != nil {
					return err
				}
				*x.WrappedOptionalString = string(b)
			}
		}
	}
	{
		if len(x.WrappedOptionalBytes) != 0 {
			var info wrapping.BlobInfo
			if err := proto.Unmarshal(x.WrappedOptionalBytes, &info); err != nil {
				return err
			}
			b, err := w.Decrypt(ctx, &info, opts...)
			if err != nil {
				return err
			}
			x.WrappedOptionalBytes = b
		}
	}
	return nil
}

func (x *TestData_Message) Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	type Wrapper interface {
		Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error
	}
	{
		if len(x.WrappedBytes) != 0 {
			info, err := w.Encrypt(ctx, x.WrappedBytes, opts...)
			if err != nil {
				return err
			}
			x.WrappedBytes, err = proto.Marshal(info)
			if err != nil {
				return err
			}
		}
	}
	{
		if len(x.WrappedString) != 0 {
			info, err := w.Encrypt(ctx, []byte(x.WrappedString), opts...)
			if err != nil {
				return err
			}
			b, err := proto.Marshal(info)
			if err != nil {
				return err
			}
			x.WrappedString = base64.RawStdEncoding.EncodeToString(b)
		}
	}
	return nil
}
func (x *TestData_Message) Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	type Unwrapper interface {
		Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error
	}
	{
		if len(x.WrappedBytes) != 0 {
			var info wrapping.BlobInfo
			if err := proto.Unmarshal(x.WrappedBytes, &info); err != nil {
				return err
			}
			b, err := w.Decrypt(ctx, &info, opts...)
			if err != nil {
				return err
			}
			x.WrappedBytes = b
		}
	}
	{
		if len(x.WrappedString) != 0 {
			b, err := base64.RawStdEncoding.DecodeString(x.WrappedString)
			if err != nil {
				return err
			}
			var info wrapping.BlobInfo
			if err := proto.Unmarshal(b, &info); err != nil {
				return err
			}
			b, err = w.Decrypt(ctx, &info, opts...)
			if err != nil {
				return err
			}
			x.WrappedString = string(b)
		}
	}
	return nil
}
