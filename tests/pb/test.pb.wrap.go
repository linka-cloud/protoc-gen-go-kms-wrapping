// Copyright 2025 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-kms-wrapping. DO NOT EDIT.

package pb

import (
	"context"

	wrapping "github.com/hashicorp/go-kms-wrapping/v2"
	wrap "go.linka.cloud/protoc-gen-go-kms-wrapping"
)

var (
	_ = wrapping.Wrapper(nil)
	_ = wrap.Wrapper(nil)
)

// Wrap wraps the sensitive struct fields with the provided wrapper.
func (x *TestData) Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	if err := wrap.WrapValue(ctx, w, &x.WrappedBytes, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedBytes {
		if err := wrap.WrapValue(ctx, w, &x.RepeatedWrappedBytes[i], opts...); err != nil {
			return err
		}
	}
	if err := wrap.WrapValue(ctx, w, &x.WrappedString, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedString {
		if err := wrap.WrapValue(ctx, w, &x.RepeatedWrappedString[i], opts...); err != nil {
			return err
		}
	}
	if err := wrap.WrapValue(ctx, w, x.WrappedMessage, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedMessage {
		if err := wrap.WrapValue(ctx, w, x.RepeatedWrappedMessage[i], opts...); err != nil {
			return err
		}
	}
	if x.WrappedBytesValue != nil {
		if err := wrap.WrapValue(ctx, w, &x.WrappedBytesValue.Value, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedBytesValue {
		if x.RepeatedWrappedBytesValue[i] != nil {
			if err := wrap.WrapValue(ctx, w, &x.RepeatedWrappedBytesValue[i].Value, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedStringValue != nil {
		if err := wrap.WrapValue(ctx, w, &x.WrappedStringValue.Value, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedStringValue {
		if x.RepeatedWrappedStringValue[i] != nil {
			if err := wrap.WrapValue(ctx, w, &x.RepeatedWrappedStringValue[i].Value, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedOptionalString != nil {
		if err := wrap.WrapValue(ctx, w, &*x.WrappedOptionalString, opts...); err != nil {
			return err
		}
	}
	if err := wrap.WrapValue(ctx, w, &x.WrappedOptionalBytes, opts...); err != nil {
		return err
	}
	return nil
}

// Unwrap unwraps the sensitive struct fields with the provided wrapper.
func (x *TestData) Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	if err := wrap.UnwrapValue(ctx, w, &x.WrappedBytes, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedBytes {
		if err := wrap.UnwrapValue(ctx, w, &x.RepeatedWrappedBytes[i], opts...); err != nil {
			return err
		}
	}
	if err := wrap.UnwrapValue(ctx, w, &x.WrappedString, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedString {
		if err := wrap.UnwrapValue(ctx, w, &x.RepeatedWrappedString[i], opts...); err != nil {
			return err
		}
	}
	if err := wrap.UnwrapValue(ctx, w, x.WrappedMessage, opts...); err != nil {
		return err
	}
	for i := range x.RepeatedWrappedMessage {
		if err := wrap.UnwrapValue(ctx, w, x.RepeatedWrappedMessage[i], opts...); err != nil {
			return err
		}
	}
	if x.WrappedBytesValue != nil {
		if err := wrap.UnwrapValue(ctx, w, &x.WrappedBytesValue.Value, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedBytesValue {
		if x.RepeatedWrappedBytesValue[i] != nil {
			if err := wrap.UnwrapValue(ctx, w, &x.RepeatedWrappedBytesValue[i].Value, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedStringValue != nil {
		if err := wrap.UnwrapValue(ctx, w, &x.WrappedStringValue.Value, opts...); err != nil {
			return err
		}
	}
	for i := range x.RepeatedWrappedStringValue {
		if x.RepeatedWrappedStringValue[i] != nil {
			if err := wrap.UnwrapValue(ctx, w, &x.RepeatedWrappedStringValue[i].Value, opts...); err != nil {
				return err
			}
		}
	}
	if x.WrappedOptionalString != nil {
		if err := wrap.UnwrapValue(ctx, w, &*x.WrappedOptionalString, opts...); err != nil {
			return err
		}
	}
	if err := wrap.UnwrapValue(ctx, w, &x.WrappedOptionalBytes, opts...); err != nil {
		return err
	}
	return nil
}

// Wrap wraps the sensitive struct fields with the provided wrapper.
func (x *TestData_Message) Wrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	if err := wrap.WrapValue(ctx, w, &x.WrappedBytes, opts...); err != nil {
		return err
	}
	if err := wrap.WrapValue(ctx, w, &x.WrappedString, opts...); err != nil {
		return err
	}
	return nil
}

// Unwrap unwraps the sensitive struct fields with the provided wrapper.
func (x *TestData_Message) Unwrap(ctx context.Context, w wrapping.Wrapper, opts ...wrapping.Option) error {
	if err := wrap.UnwrapValue(ctx, w, &x.WrappedBytes, opts...); err != nil {
		return err
	}
	if err := wrap.UnwrapValue(ctx, w, &x.WrappedString, opts...); err != nil {
		return err
	}
	return nil
}
